# OSS Maintainer/Contributor/User Interview with Julian

Convo with Julian

starting questions Questions:

- why create open source
- OS Contribution
  - Servant: web framework in Haskell
    - built with 2 friends
    - more people using it,
    - 1000 stars
  - bunch of Servant related things
  - Haskell specific libraries
    - more general
  - Started his own programming language
    - based on cool research that hasn't made it's way into actual programming languages
- what is success in open source
  - recurring contributors
  -

ASPIRATIONAL OSS

- 3 problems with open source
  - Weird status of open source as a commons
    - not funded but crucial to infra
    - unfortunate
    - if you write code and keep it to yourself you could make money, vs when you share it it's part of the public domain
    - eg if GitHub's code base would be open source it wouldn't be worth 7b
    - if you want to make money you have to find something that warrants being closed source
  - Infrastructure is such that the tooling for OS can't be good for.
    - eg i want to be able to interact with issues in terminal
    - eg automate to see if issues have a reproducible section (as specified in a contribution guide)
  - sense of alienation
    - I only know a small section of my contributors and users of my open source software
    - the better it's working the less reason there is to talk to you
    - I know who has problems, but most of the time I feel like I no idea who is using my software
    - Makes me think about this idea of investing in the project
-
-
- 3 opportunities
  - financing developers and maintainers
  - Idea of certificate of impact
    - every time somebody does something good for the world, let's have a system that "this person did this"
    - Person could sell this certificate, and the person that bought it basically funding after the fact and hence contributing to do this
    - rethinking a little bit, OS need a fairly novel idea that rethinks it a bit
    - case of the art market, we want the real painting on our wall, so we do give some validity to the artist, it's not just about the painting
  - Having access to primitives to create your own tooling
    - the internet is a detraction of the flexibility of the command line
      - for example, instead of having just a webpage sending you a GUI with the data in there, it could send you the GUI and the data separately and let you choose to see just the data or the default GUI with the data
      - e.g. repo in Github with all the issues
      - services don't want to do that cause it's the best way to lock users in to the service

PRACTICAL OSS

- Roles
  - existing
    - user
    - maintainer
    - contributor
    -
  - future
    - investor
      - Someone makes explicit the financial incentive that they have to see the project go well
-
-
- list Tasks to do as maintainer
  - answering questions
  - checking if bugs are real
  - fixing bugs
  - reviewing code
  - talking at conferences
  - evangelising
  - facilitating contributions
  - maintaining: slowly things get worse when multiple people work on it (wear and tear of collaboration
  - TIME CONSUMING ONE:
    - leading and communicating large scale changes of the project
      - eg switching fundamental library
  - FAVOURITE TASK
    - discussing ideas
      - IRC / in person
      - could be based on an OSS that you've written communication could be rewriting part of the code
-
-
- lifecycle of project
  - was working remotely for a Haskell company
  - very effective team
  - had some down time because of rest of company was lagging behind
  - had some experience writing web services
  - independently had a break and wanted to write some tools to help himself with it
  - discovered that 2 other people were doing the same thing
  - join efforts
  - his idea was more along and more understandable
  - other ideas were weird, and he looked at it and liked how great it was
  - had a sense that it actually wouldn't work
  - starting tackling all the unknowns to see where it breaks
  - as a challenge, how far can we go before it works
  - kept on going, and starting to understand how all of it fits togethers
  - spend a month on IRC working on
  - was using GitHub & might have been public from the start
  - conversations were mostly over IRC, GitHub was hosting and VCS
  - project was usable for them and then they decided to write readme documentation tutorials etc
  - packaged all of that and released it
  - shared it on the Haskell mailing list + Haskell Reddit forum
  - people got interested
  - companies started using it almost immediately
  - people in that company contributed a lot
  - immediately 4-5 people that contributed very regularly
  - they all had commit power quite quickly since they were recurring
  - friend told you to write a paper
  - which he did
  - that friend and the paper brought in a whole new set of ideas and a lot of new development began then
  - did a lot of conferences
  - now 3 years later:
    - 2 original maintainers stepped out, 1 largely stopped writing code
    - new maintainer took over, really prolific
    - about 100 people that have contributed in total
    - before when issue happened it was something new and exciting
    - now issues are a lot more general and the same, more about opinions
    - there is 1 more last major change that is being worked on
      - less and less collaborative, the project becomes less and less yours
      - thats a bit annoying but also not
        - wasn't involved, but could have been, so I can't complain
        - there's a sense that everything you do is better then what
        - but I don't feel sense of duty about it anymore, which is nice
        - for a while maintaining took a large part of my life
          - 2-3 hours a day outside of work
- tools at your disposal
  - Github
  - CI
  - IRC
  - Mailing list (Haskell and servant)
  - static pages
  - docs static page
  -

1. go through questions & add answers to document

2. Collect feedback on doc

3. Show architecture visualisation & add to it
